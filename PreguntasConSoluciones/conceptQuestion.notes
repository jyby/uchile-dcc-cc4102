#+DRAWERS: PROPERTIES LOGBOOK CLOCK PROOF SOLUTION CONTEXT
#+TODO: NEXT(n) MAYB(m) TODO(t) ACTF(a) PAUS(p) WAIT(w) | DONE(d) CANC(c)
#+TAGS: CQ(C) READING(R) TALK(T)
#+LATEX_HEADER: \usepackage{fullpage}
#+LATEX_HEADER: \usepackage[spanish]{babel}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+OPTIONS: LaTeX:dvipng H:5 num:t

#+TITLE: Diseño y Análisis de Algoritmos - Preguntas
#+AUTHOR: Jérémy Barbay

* How to Include Concept Questions inside your lecture notes 				 
*** PREGUNTAS [0/0]						  :PREGUNTAS:
**** Title of the question
     :SOLUTION:     
     :END:
     :PROOF: 
     :END:
     Text of the question
     1. [ ] Answer 1
     2. [ ] Answer 2
     3. [ ] Answer 3
     4. [ ] Answer 4
     5. [ ] none of the above

**** 
     :SOLUTION:     
     :END:
     :PROOF: 
     :END:
     :CONTEXT:
     :END:
     
     1. [ ] 
     2. [ ] 
     3. [ ] 
     4. [ ] 
     5. [ ] otra respuesta
* Introduciendo "Concept questions": "Hanoi Tower" y "Disk Pile"
  :LOGBOOK:
  - State "DONE"       from "NEXT"       [2011-03-03 Thu 10:17]
  :END:
  :PROPERTIES:
  :Effort:   20
  :Energy:   ZERO
  :Span:     hour
  :END:
** Una corta historia sobre "Concept Questions"			       :TALK:
   - Charla de Eric Mazur:
     - http://www.youtube.com/watch?v=WwslBPj8GgI
   - Grupo de Investigacion sobre "Peer Instruction"
     - http://mazur-www.harvard.edu/research/detailspage.php?rowid=8
** Torre de Hanoi de altura 4					  :PREGUNTAS:
   :PROPERTIES:
   :END:
   :SOLUTION: 
   none of the above
   :END:
   :PROOF: 
   - The complexity is *not* $2^{n}$ (think about the complexity to move a single disk).
   - f(1)=1; f(n+1) = 2*f(n)+1 yields
     | 1 | 2 | 3 |  4 |  5 |  6 |   7 |   8 |
     |---+---+---+----+----+----+-----+-----|
     | 1 | 3 | 7 | 15 | 31 | 63 | 127 | 253 |
   :END:
   What is the minimum number of moves required to move a Hanoi Tower of height $4$?
     1) [ ] $4$
     2) [ ] $4*\lg 4=4*2=8$
     3) [ ] $4!=4*3*2*1 = 24$
     4) [ ] $2^4 = 32$
     5) [ ] none of the above

** Torre de Hanoi de altura 8					  :PREGUNTAS:
   :PROPERTIES:
   :END:
   :SOLUTION: 
   none of the above
   :END:
   :PROOF: 
   - The complexity is *not* $2^{n}$ (think about the complexity to move a single disk).
   - f(1)=1; f(n+1) = 2*f(n)+1 yields
     | 1 | 2 | 3 |  4 |  5 |  6 |   7 |   8 |
     |---+---+---+----+----+----+-----+-----|
     | 1 | 3 | 7 | 15 | 31 | 63 | 127 | 253 |
   :END:
   What is the minimum number of moves required to move a Hanoi Tower of height $8$?
     1) [ ] $8$
     2) [ ] $8*\lg 8=8*3=24$
     3) [ ] $2^8 = 254$
     4) [ ] $8! = 8*7*6*5*4*3*2*1 = 40320$
     5) [ ] none of the above

** Disk Pile of height 8					  :PREGUNTAS:
   :PROPERTIES:
   :SOLUTION: 
   8   
   :END:
   :SOLUTION: 
   $8$
   :END:
   :PROOF: 
   The "minimum" can refer not only to the optimality of the
   solution, but also to the choice of the instance.  The easiest
   instance of moving a disk pile is when all the disks have the
   same size, and hence can be moved in linear time.
   :END:
   What is the minimum number of moves required to move a disk pile
   of height $8$?
     1) [ ] $8$
     2) [ ] $8*\lg 8=8*3=24$
     3) [ ] $2^8$
     4) [ ] $8!=8*7*6*5*4*3*2*1=?$
     5) [ ] none of the above

** Disk Pile of height 8 with 2 disk sizes			  :PREGUNTAS:
   :PROPERTIES:
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:
   What is the minimum number of moves required to move a disk pile
   of height $8$ in the worst case over the instances with exactly
   two distinct sizes of disc?
     1) [ ] $8$
     2) [ ] $8*\lg 8=8*3=24$
     3) [ ] $2^8$
     4) [ ] $8!=8*7*6*5*4*3*2*1=?$
     5) [ ] none of the above



* Revisiones de CC3001
** Asintóticas								 :CP:
       :LOGBOOK:
       - State "DONE"       from "TODO"       [2011-03-15 Tue 11:05]
       - State "TODO"       from ""           [2011-03-10 Thu 11:55]
       :END:
| $f(n)$            | $g(n)$          | $f(n)\in O(g(n)$ | $f(n)\in \Omega(g(n)$ | $f(n)\in Theta(g(n)$ |
|-------------------+-----------------+------------------+-----------------------+----------------------|
| $3n+6$            | $100n-50$       |                  |                       |                      |
| $n^{\frac{1}{2}}$ | $n^\frac{2}{3}$ |                  |                       |                      |
** ¿Cuántos árboles binarios distintos se pueden construir con 3 nodos internos?
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2011-03-15 Tue 11:06]
   - State "TODO"       from ""           [2011-03-10 Thu 11:55]
   :END:
   1. [ ] 1
   2. [ ] 3
   3. [ ] 4
   4. [ ] 6
   5. [ ] otra
** Arboles Binarios, nodos internos externos
   Si se define i = número de nodos internos, e = número de nodos
   externos, entonces se tiene que:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2011-03-15 Tue 11:06]
   - State "TODO"       from ""           [2011-03-10 Thu 11:55]
   :END:
   1. [ ] i = e
   2. [ ] e = i+1
   3. [ ] i = e+1
   4. [ ] e = 2^i
   5. [ ] sin relación
** Sea n = número de nodos internos. Se define:
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2011-03-15 Tue 11:06]
    - State "TODO"       from ""           [2011-03-10 Thu 11:55]
    :END:
 * In = suma del largo de los caminos desde la raíz a cada nodo
   interno (largo de caminos internos).
 * En = suma del largo de los caminos desde la raíz a cada nodo
   externo (largo de caminos externos).
   Se tiene que:
   1. [ ] En = In
   2. [ ] En = In+1
   3. [ ] En = In+n
   4. [ ] En = In+2n
   5. [ ] sin relación
** Heap
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2011-03-15 Tue 11:06]
   - State "TODO"       from ""           [2011-03-10 Thu 11:55]
   :END:
   La característica que permite que un heap se pueda almacenar
   sin punteros es que, si se utiliza la numeración por niveles
   indicada, entonces la(s) relación(es) entre padres e hijos es
   (son):
   1. [ ] Hijos del nodo $j = \{2*j, 2*j+1\}$
   2. [ ] Padre del nodo $k = \lfloor k/2 \rfloor$ 
   3. [ ] Hijos del nodo $j = \{2*j-1, 2*j\}$
   4. [ ] Padre del nodo $k = \lfloor k/2 \rfloor +1$
   5. [ ] ningunos
** AVL
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2011-03-15 Tue 11:06]
   :END:
   La altura de un AVL con $n$ elementos es  
   1. [ ] $\log_\phi(n+1)+\Theta(1)$
   2. [ ] en $O(\lg n)$
   3. [ ] en $\Omega(\lg n)$
   4. [ ] en $\Theta(\lg n)$
   5. [ ] ningunos o mas que dos
** AVL $h-> n$
   :SOLUTION:
   5. otra respuesta
   :END:
   :PROOF:
   (ref http://www.dcc.uchile.cl/~bebustos/apuntes/cc3001/Diccionario/#3  )
   Sea $n_h$ el tamaño del árbol AVL mas pequeño de altura $h$.
   Experimentalmente, 
   | $h$   | 1 | 2 | 3 | 4 |  5 |
   |-------+---+---+---+---+----|
   | $n_h$ | 2 | 3 | 5 | 8 | 13 |
   Recursivamente, un tal árbol tiene
   - un hijo de altura $h-1$ y con $n_{h-1}$ nodos
   - un hijo de altura $h-2$ y con $n_{h-2}$ nodos 

   Así $n_h = 1+n_{h-1}+n_{h-2}$: es la forma de la secuencia de
   Fibonacci (con distintas condiciones iniciales)!  

   La solución es $n_h=\frac{\phi^{h+2}}{\sqrt{5}}$ (que no es en
   la lista).
   :END:
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-15 Tue 12:08]
   - State "NEXT"       from "TODO"       [2011-03-15 Tue 11:06]
   :END:
   para una altura $h$ dada, cuantos nodos tiene un árbol AVL con
   *mínimo* número de nodos que alcanza esa altura?
   1. [ ] $h$
   2. [ ] $2h$
   3. [ ] $2^h$
   4. [ ] $2^h-1$
   5. [ ] otra respuesta
* Cotas Superiores/Inferiores 
** Cota superior de (la complejidad de) Max ord
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-15 Tue 12:20]
   :END:
   Dado un arreglo ordenado de $n$ enteros, en cuanto accessos al
   arreglo pueden  calcular su valor maximal?
   1. [ ] $0$
   2. [ ] $1$
   3. [ ] $n-1$
   4. [ ] $n$
   5. [ ] otra
** Definicion de la mediana
   Dado un arreglo de $n$ enteros, cual es la definicion correcta
   de la mediana?
   1. [ ] El promedio de las valores minima y maxima del arreglo.
   2. [ ] La valor en el centro del arreglo.
   3. [ ] La valor en el centro del arreglo ordenado.
   4. [ ] La valor superior a $\lceil(n-1)/2\rceil$ valores y inferior a $\lfloor(n-1)/2\rfloor$ valores. 
   5. [ ] otra respuesta.
** Dificultad de problemas en arreglos
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-15 Tue 13:39]
   :END:
   Dado un arreglo de $n$ enteros, cual problema requiere mas
   accessos al arreglo? Mas computacion?
   1. [ ] Calcular la valor minima
   2. [ ] Calcular la valor maxima
   3. [ ] Calcular la valor mediana
   4. [ ] Calcular la valor promedia
   5. [ ] Son todos iguales
** Cota Inferior para Max
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-15 Tue 13:39]
   - State "NEXT"       from ""           [2011-03-15 Tue 11:08]
   :END:
   Dado un arreglo de $n$ enteros, cuanto comparaciones entre los
   elementos del arreglo se necessitan para calcular su valor
   maximal?
   1. [ ] $0$
   2. [ ] $1$
   3. [ ] $n-1$
   4. [ ] $n$
   5. [ ] otra respuesta
** Definicion del problema de MinMax
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-15 Tue 13:39]
   :END:
   Dado un arreglo $A$ de $n$ enteros, cual es la definicion del
   problema de "minmax"?
   1. [ ] calcular $\min_{i\in[1..n],j\in[i..n]} A[i]$
   2. [ ] calcular $\min_{i\in[1..n]} \max{j\in[i..n]} A[i]$
   3. [ ] calcular $(\min_{i\in[1..n]} A[i], \max_{i\in[1..n]} A[i])$
   4. [ ] calcular $(\min_{i\in[1..n]} A[i], \max_{j\in[1..n]} A[j])$
   5. [ ] otra respuesta
   
** Cotas de (la complejidad de) problemas combinados
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-15 Tue 13:39]
   :END:
   Dado dos problemas $A$ y $B$ (e.g. min y max), cada uno con un
   algoritmo que le resuelve optimalemente con complejidad $f_A(n)$
   y $f_B(n)$, cual es la complejidad del problema $AB$ (e.g. min
   max)?
   1. [ ] $\min\{f_A(n)$ , f_B(n)\}$
   2. [ ] $f_A(n)$ + f_B(n)$
   3. [ ] $(f_A(n)$ + f_B(n))/2$
   4. [ ] $\max\{f_A(n)$ , f_B(n)\}$
   5. [ ] otra respuesta
** Cota *superior* de (la complejidad de) Min Max
    :LOGBOOK:
    - State "DONE"       from "NEXT"       [2011-03-15 Tue 13:39]
    :END:
 :SOLUTION:     
 $3n/2-2$ si $n$ es par, $3n/2 + 1/2$ si $n$ es impar.
 :END:
 :PROOF: 
 cf apuntes
 :END:
    Dado un arreglo de $n$ enteros, en cuanto comparaciones
    (cantidad exacta, no asimptotica) entre los elementos del
    arreglo pueden calcular su valor maximal y minimal?
    1. [ ] $n-1$
    2. [ ] $3n/2-2$ si $n$ es par, $3n/2 + 1/2$ si $n$ es impar.
    3. [ ] $(n-1)+(n-2)$
    4. [ ] $2(n-1)$
    5. [ ] otra respuesta
** Cota *inferior* de (la complejidad de) Min Max
 :SOLUTION:     
 $\lceil 3n/2 \rceil-2$
 :END:
 :PROOF: 
 cf apuntes
 :END:
    Dado un arreglo de $n$ enteros, cuanto comparaciones (cantidad
    exacta, no asimptotica) entre los elementos del arreglo se
    necessitan para calcular su valor maximal y minimal?
    1. [ ] $n-1$
    2. [ ] $\lceil 3n/2 \rceil-2$
    3. [ ] $(n-1)+(n-2)$
    4. [ ] $2(n-1)$
    5. [ ] otra respuesta
** Juego de las preguntas, $n=4$
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-17 Thu 13:32]
   - State "NEXT"       from "CANC"       [2011-03-16 Wed 17:55]
   - State "CANC"       from "NEXT"       [2011-03-16 Wed 17:49]
   :END:
   :SOLUTION:
   $2$
   :END:
   :PROOF:
   - $x<3$?
     - $x<2$
       - 1
       - 2
     - $x<4
       - 3
       - 4
   :END:
   Cuanta preguntas (e.g. "$x<4$?", "x=2"?)  se necesitan para
   adivinar un entero entre $1$ y $4 (i.e. $x\in[1..4]$)?
   1. [ ] 1
   2. [ ] 2
   3. [ ] 3
   4. [ ] 4
   5. [ ] otra
** Juego de las preguntas, $n=1024$
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-17 Thu 13:32]
   :END:
   :SOLUTION:
   $\log 1024=10$
   :END:
   :PROOF:
   - Cada pregunta permite de reducir el tamano del domanio por dos.
   - $1024=2^10$ es divido 10 veses por $10$ antes de ser reducido a $1$
   - como sabemos que $x$ es un entero (en el rango), es suficiente
   :END:
   Cuanta preguntas (e.g. "$x<10$?", "x=10"?)  se necesitan para
   adivinar un entero entre $1$ y $1024$?
   1. [ ] 8
   2. [ ] 9
   3. [ ] 10
   4. [ ] 11
   5. [ ] otra

** Codificacion de un simbolo
   :SOLUTION:
   Dado 1 simbolo elegido a dentro de $[1..\sigma]$
   1. [ ] no se puede codificar *nunca* en $o(\lg\sigma)$ bits
   2. [X] no se puede codificar *siempre* en $o(\lg\sigma)$ bits
   3. [X] no se sabe *como codificar siempre* en $o(\lg\sigma)$ bits
   4. [ ] no se sabe *si nunca se puede codificar* en $o(\lg\sigma)$ bits
   5. [ ] otra
   :END:
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-17 Thu 13:32]
   :END:
   Dado 1 simbolo elegido a dentro de $[1..\sigma]$
   1. [ ] no se puede codificar *nunca* en $o(\lg\sigma)$ bits
   2. [ ] no se puede codificar *siempre* en $o(\lg\sigma)$ bits
   3. [ ] no se sabe *como codificar siempre* en $o(\lg\sigma)$ bits
   4. [ ] no se sabe *si nunca se puede codificar* en $o(\lg\sigma)$ bits
   5. [ ] otra

** Definicion de un arbol de decision
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-17 Thu 13:32]
   - State "NEXT"       from ""           [2011-03-17 Thu 11:55]
   :END:
   :SOLUTION:
   Un arbol de decision es definido como un arbol
   1. [ ] modelisando algoritmos en el modelo de
	  comparacion.
   2. [ ] binario donde cada hoja identifica una instancia.
   3. [ ] binario donde cada nodo prueba una caracteristica de la
	  instancia.
   4. [X] un arbol de grado finito donde cada hoja indica una
	  decision sobre la instancia.
   5. [ ] otra.
   :END:
   :PROOF:
   :END:
   Un arbol de decision es definido como un arbol
   1. [ ] modelisando algoritmos en el modelo de
	  comparacion.
   2. [ ] binario donde cada hoja identifica una instancia.
   3. [ ] binario donde cada nodo prueba una caracteristica de la
	  instancia.
   4. [ ] un arbol de grado finito donde cada hoja indica una
	  decision sobre la instancia.
   5. [ ] otra.


** Codificacion de $n$ simbolos
   :SOLUTION:
   Dado $n$ simbolos elegido a dentro de un alfabeto de tamaño  $\sigma$
   1. [ ] no se puede codificar *nunca* en $o(n\lg\sigma)$ bits
   2. [X] no se puede codificar *siempre* en $o(n\lg\sigma)$ bits
   3. [X] no se sabe *como codificar siempre* en $o(n\lg\sigma)$ bits
   4. [ ] no se sabe *si nunca se puede codificar* en $o(n\lg\sigma)$ bits
   5. [ ] otra
   :END:
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-17 Thu 13:32]
   :END:
   Dado $n$ simbolos elegido a dentro de un alfabeto de tamaño  $\sigma$
   1. [ ] no se puede codificar *nunca* en $o(n\lg\sigma)$ bits
   2. [ ] no se puede codificar *siempre* en $o(n\lg\sigma)$ bits
   3. [ ] no se sabe *como codificar siempre* en $o(n\lg\sigma)$ bits
   4. [ ] no se sabe *si nunca se puede codificar* en $o(n\lg\sigma)$ bits
   5. [ ] otra
** Definicion de "InsertionRank"
   :SOLUTION:
   1. [ ] la posicion en cual $x$ deberia ser insertado por dejar
	  $A$ ordenado
   2. [X] el entero $p\in[1..n+1]$ tal que $A[p-1]<x \leq A[p]$
   3. [ ] el entero $p\in[0..n]$ tal que $A[p]\leq x < A[p+1]$
   4. [ ] el entero $p\in[1..n]$ tal que $x = A[p]$
   5. [ ] ningunos o mas que dos 
   :END:
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-17 Thu 13:32]
   :END:
   Dado un arreglo ordenado $A[1..n]$ de $n$ valores y una valor
   $x$, cual(es) de estas definiciones del /Posicion de Insercion/
   ("Insertion Rank") de $x$ en $A$ son incorectas?
   ($A[0]=-\infty$ y $A[n+1]=+\infty$)
   1. [ ] la posicion en cual $x$ deberia ser insertado por dejar
	  $A$ ordenado
   2. [ ] el entero $p\in[1..n+1]$ tal que $A[p-1]<x \leq A[p]$
   3. [ ] el entero $p\in[0..n]$ tal que $A[p]\leq x < A[p+1]$
   4. [ ] el entero $p\in[1..n]$ tal que $x = A[p]$
   5. [ ] ningunos o mas que dos 
** Dos tipos de busqueda ordenada
   :SOLUTION:
   :END:
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-17 Thu 13:32]
   :END:
   Dado el codigo siguente, cual es la mejor manera de completarlo
   para minimizar la complejidad (non asymptotica) en el peor caso?
   El el caso promedio?

   insertionRank(x,A,l,r) { 
     if( $r-l<2$ ) return $l$ else { m=(l+r)/2; ... }
   }
 
   1. [ ] if( $x<A[m]$ )  return insertionRank(x,A,l,m)
	  else if( $x>A[m]$ )  return insertionRank(x,A,m,r)
	  else if( $x=A[m]$ )  return $m$
	  endif
   2. [ ] if( $x=A[m]$ )  return $m$
	  else if( $x<A[m]$ )  return insertionRank(x,A,l,m)
	  else if( $x>A[m]$ )  return insertionRank(x,A,m,r)
	  endif
   3. [ ] if( $x=A[m]$ )  return $m$
	  else if( $x<A[m]$ )  return insertionRank(x,A,l,m)
	  else return insertionRank(x,A,m,r)
	  endif
   4. [ ] if( $x<A[m]$ )  return insertionRank(x,A,l,m)
	  else return insertionRank(x,A,m,r)
	  endif
   5. [ ] performan iguales todos en el peor caso.
	  
** Cota inferior por busqueda ordenada $n=1024$.
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-17 Thu 13:32]
   :END:
   :SOLUTION:
   $1+\log 1024=11$
   :END:
   :PROOF:
   - Cada comparacion permite de reducir el tamano del domanio por dos.
   - $1024=2^10$ es divido 10 veses por $10$ antes de ser reducido a $1$
   - como NO sabemos si $x$ partenece a $A$, necesitamos una comparacion mas.
   :END:
   Dado un arreglo ordenado $A$ de $1024$ enteros y un entero $x$,
   cuanto comparaciones con elementos del arreglo son necesarias
   para decidir si $x$ pertenece a $A$ (en el peor caso)?
   1. [ ] 9
   2. [ ] 10
   3. [ ] 11
   4. [ ] 1024
   5. [ ] otra

** Cota inferior por busqueda ordenada general $n$.
   :SOLUTION:
   :END:
   :PROOF:
   :END:
   Dado un arreglo ordenado $A$ de $n$ enteros y un entero $x$,
   cuanto comparaciones con elementos del arreglo son necesarias
   para decidir si $x$ pertenece a $A$ (en el peor caso)?
   2. [ ] $\lceil\lg n\rceil$
   2. [ ] $1+\lceil\lg n\rceil$
   3. [ ] $n-1$
   4. [ ] $n$
   5. [ ] otra

** Definicion del modelo de comparacion
   :LOGBOOK:
   - State "TODO"       from "NEXT"       [2011-03-22 Tue 12:28]
   :END:
   :SOLUTION:
   :END:
   :PROOF:
   :END:
   Cuales de estos algoritmos simples son en el modelo de
   comparacion?
   1. [ ] c=0; for(int i=1; i<n; i++) { if(A[i]>A[i+1]) c++;}
   2. [ ] for(int i=1; i<n; i++) { if(A[i]>A[i+1]) print i;}
   ; 3. [ ] for(int i=1; i<n; i++) { if(A[i]>A[i+1]) print i;}
   ; 4. [ ] for(int i=1; i<n; i++) { if(A[i]>A[i+1]) print i;}
   5. [ ] ningunos

** Relacion entre codificacion y busqueda
    :LOGBOOK:
    - State "DONE"       from "NEXT"       [2011-03-26 Sat 17:51]
    - State "NEXT"       from ""           [2011-03-17 Thu 12:01]
    :END:
 :SOLUTION:     
 A cada algoritmo de busqueda corresponde una codificacion de enteros.
 :END:
 :PROOF: 
    1. [X] A cada algoritmo de busqueda corresponde una codificacion
	   de enteros. -> Considera el algoritmo de interpolacion:
	   no le corresponde una codificacion de entero, al menos no
	   con la reduccion vista en curso.
    2. [ ] A cada codificacion de enteros corresponde un algoritmo
	   de busqueda. -> El algoritmo de decodificacion es un
	   algoritmo de busqueda, preguntando a cada bit alguna
	   informacion.
    3. [ ] A algunos algoritmos de busqueda corresponde una
	   codificacion de enteros -> busqueda binaria y codigo
	   binario es un ejemplo.
    4. [ ] A algunas codificaciones de enteros corresponde un
	   algoritmo de busqueda -> codigo binario y busqueda
	   binarya.
 :END:
    Cual de estas aserciones es falsa en el modelo de comparacion?
    1. [ ] A cada algoritmo de busqueda corresponde una codificacion
	   de enteros.
    2. [ ] A cada codificacion de enteros corresponde un algoritmo
	   de busqueda.
    3. [ ] A algunos algoritmos de busqueda corresponde una
	   codificacion de enteros
    4. [ ] A algunas codificaciones de enteros corresponde un
	   algoritmo de busqueda.
    5. [ ] otra
** Busqueda Doblada
     :LOGBOOK:
     - State "DONE"       from "NEXT"       [2011-03-22 Tue 12:58]
     - State "NEXT"       from ""           [2011-03-22 Tue 11:47]
     :END:
  :SOLUTION:     
  ningunas
  :END:
  :PROOF: 
     1. [ ] $\lg(1+n)$ comparaciones -> Busqueda binaria
     2. [ ] $p+1$ comparaciones -> Busqueda secuencial
     3. [ ] $2\lg p$ comparaciones -> Busqueda dublada
     3. [ ] $2\lg(n-p)$ comparaciones -> Busqueda dublada, iniciando a la derecha
 :END:
     Cual de las asercions siguentes son falsas?
     Dado una valor $x$ y un arreglo ordenado $A$ de $n$ valores,
     existe un algoritmo calculando la posicion de inserción $p$ de
     $x$ en $A$ en 
     1. [ ] $\lg(1+n)$ comparaciones
     2. [ ] $p+1$ comparaciones
     3. [ ] $2\lg p$ comparaciones
     3. [ ] $2\lg(n-p)$ comparaciones
     5. [ ] ningunas o mas que dos.
** Compression de enteros
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-22 Tue 12:59]
   - State "NEXT"       from ""           [2011-03-22 Tue 11:48]
   :END:
   Dado un entero $x\in[1..n]$, existe un esquema de
   codificacion representando $x$ con 
   1. [ ] $\lg n$ bits,
   2. [ ] $2\lg p$ bits,
   3. [ ] $p$ bits,
   4. [ ] $2\lg(n-p)$ bits,
   6. [ ] ningunas o mas que dos.
** Cota inferior ordenamiento (en el modelo de comparacion)
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-17 Thu 11:53]
   :END:
   :SOLUTION:
   :END:
   :PROOF:
   :END:
   Decir que "Ordenar es en $\Omega(n\lg n)$ (en el modelo de
   comparacion) significa que
   1. [ ] no se puede ordenar en $o(n\lg n)$  comparaciones
   2. [ ] ninguno algoritmo conocido (del modelo de comparacion)
	  ordena en $o(n\lg n)$ comparaciones
   3. [ ] no se puede ordenar en tiempo $o(n\lg n)$ 
   4. [ ] ninguno algoritmo conocido (del modelo de comparacion)
	  ordena en tiempo $o(n\lg n)$
   5. [ ] otra respuesta

** Complejidad en promedio de un algoritmo
   :SOLUTION:
   Ningunas. Falta una distribucion $(p_i)_{i\in[1..2^n]}$ sobre
   las instancias legales por $A$ de tamaño $n$
   :END:
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-22 Tue 11:55]
   - State "NEXT"       from ""           [2011-03-22 Tue 11:48]
   :END:
   Dado un entero fijado $n$, un algoritmo deterministico $A$. Cual
   de estas definiciones corresponde a la complejidad en promedio
   de $A$?
   1. [ ] $\sum_{x,|x|=n} C(A,x)/n$
   2. [ ] $\sum_{x,|x|=n} C(A,x)/2^n$
   3. [ ] $\sum_{x,|x|=n} C(A,x) / \#\{x, |x|=n\}$
   4. [ ] El promedio de su complejidad sobre cada instancia.
   5. [ ] ningunas o mas de dos.
** Complejidad en promedio de un problema
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-22 Tue 11:54]
   - State "NEXT"       from ""           [2011-03-22 Tue 11:48]
   :END:
   Dado un problema $Pb$, un entero fijado $n$, un conjunto
   $X_n=(x_i)_{i\in[1..2^n]}$ de instancias legales por $Pb$ y una
   distribucion $(p_i)_{i\in[1..2^n]}$ sobre $X_n$. La complejidad
   en promedio de $Pb$ es
   1. [ ] $\max_A \sum_i p_i C(A,x_i)$
   2. [ ] $\min_A \sum_i p_i C(A,x_i)$
   3. [ ] $\sum_i p_i \max_A C(A,x_i)$
   4. [ ] $\sum_i p_i \min_A C(A,x_i)$
   5. [ ] ningunas
** Complejidad aleatorizada
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-22 Tue 11:48]
   :END:
   1. [ ] 
** Relacion entre Complejidad en Promedio y en el peor caso
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-17 Thu 10:30]
   :END:
   * Nota
     - $C(A,I)$ la complejidad de un algoritmo $A$ sobre la
       instancia $I$, y
     - $E_I(C(A,I))$ la complejidad en el peor caso sobre las
       instancias de tamano $n$, y
     - $E_I(C(A,I))$ la complejidad en promedio por la distribucion
       uniforme sobre las instancias de tamano $n$.
   * Cuales de estas relaciones son verdad?
     1. [ ] $E_I(C(A,I)) \leq \max_I C(A,I)$
     2. [ ] $E_I(C(A,I)) < \max_I C(A,I)$
     3. [ ] La complejidad en el peor caso (de un algoritmo) es siempre peor que la complejidad en promedio
     4. [ ] La complejidad en promedio (de un algoritmo) nunca es peor que la complejidad en el peor caso
     5. [ ] ningunas

** Tecnicas de cotas inferiores
   :LOGBOOK:
   - State "DONE"       from "NEXT"       [2011-03-22 Tue 13:19]
   :END:
   Cual(es) de las tecnicas siguentes permitten de mostrar cotas
   inferiores para la complejidad en promedio?
     1. [ ] lemma del ave
     2. [ ] Estrategia de Adversario
     3. [ ] Arbol Binario de Decision
     4. [ ] lemma del minimax
     5. [ ] ningunas o mas de dos.
* Experimentacion
** Cuantos segundos vale 1ns?
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-29 Tue 10:49]
   :END:
   :SOLUTION:     
   | 1 nano  | $10^{-9}$ |
   :END:
   :PROOF: 
   | 1 nano  | $10^{-9}$ |
   | 1 micro | $10^{-6}$ |
   | 1 mili  | $10^{-3}$ |
   | 1 centi | $10^{-2}$ |
   |         |           |      
   :END:
   Cuántos segundos vale un nano segundo?
   1. [ ] $10^{-12}$ segundos
   2. [ ] $10^{-9}$ segundos
   3. [ ] $10^{-6}$ segundos
   4. [ ] $10^{-3}$ segundos
   5. [ ] otra respuesta
** Camino de acceso a valores
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-29 Tue 10:51]
   :END:
   :SOLUTION:     
   :END:
   :PROOF: 
   - Registro mas =frecuente= si sistema bien hecho
   - =probable= no bien definido, pero en todo caso un aceso a
     cualquier nivel mas bajo que Registro resulta tambien en un
     acceso a todos los niveles mas cercano del CPU, asi que
     deberia ser =otra respuesta=.
   :END:
   Cuando un programa hace un acceso a dos elementos de un arreglo,
   cual es el camino de accesso a estas valores el mas \{frecuente
   / probable \}?
   1. [ ] Registros
   2. [ ] Caches (1,2 o 3)
   3. [ ] RAM (principal)
   4. [ ] Disco Duro
   5. [ ] otra respuesta
   6. [ ] Cache + RAM + Disco Duro
   7. [ ] Cache + Disco Duro
   8. [ ] RAM + Disco Duro
** Cual es la significacion de GHz?				       :CANC:
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-29 Tue 11:01]
   :END:
   :SOLUTION:     
   $4.10^9$ ciclos per segundas, i.e. un poco menos que $4.10^9$
   instrucciones per segundas.
   :END:
   :PROOF: 
   The hertz is equivalent to cycles per second. (... ) commonly
   used multiples are kHz (kilohertz, $10^3$ Hz), MHz (megahertz,
   $10^6$ Hz), GHz (gigahertz, $10^9$ Hz) and THz (terahertz,
   $10^12$ Hz). (...) For home-based personal computers, the CPU
   has ranged from approximately 1 megahertz in the late 1970s
   (Atari, Commodore, Apple computers) to up to 6 GHz in the
   present (IBM POWER
   processors). http://en.wikipedia.org/wiki/Hertz
   :END:
   Que significa que un procesador funciona a 4 GHz?
   1. [ ] $4$ instrucciones per segunda
   2. [ ] $4*10^3$ instrucciones per segundo
   3. [ ] $4*10^6$ instrucciones per segundo
   4. [ ] $4*10^9$ instrucciones per segundo
   5. [ ] otra respuesta
** Nivel a 25ns
      :LOGBOOK:
      - State "NEXT"       from ""           [2011-03-29 Tue 10:54]
      :END:
      :SOLUTION:     
      RAM
      :END:
      :PROOF: 
      100 ciclos = 100 * .25ns = 25 ns  => RAM
|        | Registro | L1         | L2       | L3       | RAM        | Disco         | Red           | Static   |
|--------+----------+------------+----------+----------+------------+---------------+---------------+----------|
| tiempo | 1 ciclo  | O(1) ciclo | L1*2,*10 | >L2      | 100 ciclos | $10^6$ ciclos | O(1) Segundas | sin cota |
| tamaño | 100  B   | 10 KB      | >512 KB  | >2048 KB | O(1) GB    | 200 GB        | creciendo     | sin cota |
      :END:
      Cual de los niveles siguentes parece el mas cerca de un tiempo
      de acceso de 25 ns, por un computador funcionando a 4 GHz?
      1. [ ] Registro
      2. [ ] Cache (L1, L2 o L3)
      3. [ ] RAM
      4. [ ] Disco duro
      5. [ ] otra respuesta
** Nivel a 1ns
      :LOGBOOK:
      - State "NEXT"       from ""           [2011-03-29 Tue 10:54]
      :END:
      :SOLUTION:     
      Cache (*L1*, L2 o L3)
      :END:
      :PROOF: 
      O(1) ciclos ~ 1ns
|             | Registro | L1         | L2       | L3       | RAM        | Disco         | Red           | Static   |
|-------------+----------+------------+----------+----------+------------+---------------+---------------+----------|
| tiempo      | 1 ciclo  | O(1) ciclo | L1*2,*10 | >L2      | 100 ciclos | $10^6$ ciclos | O(1) segundas | sin cota |
| orden en ns | .25 ns   | 1ns        | 5ns      | 10ns     | 25ns       | 250.000 ns    | 10^9 ns       | sin cota |
| tamaño      | 100 b    | 10 Kb      | >512 Kb  | >2048 Kb | O(1) Gb    | 200 Gb        | creciendo     | sin cota |
      :END:
      Cual de los niveles siguentes parece el mas cerca de un tiempo
      de acceso de 1 ns, por un computador funcionando a 4 GHz?
      1. [ ] Registro
      2. [ ] Cache (L1, L2 o L3)
      3. [ ] RAM
      4. [ ] Disco duro
      5. [ ] otra respuesta
** Cuanto se demora una instruccion?
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-29 Tue 10:59]
   :END:
   :SOLUTION:     
   1 ns (.25 para un ciclo, pero algunas isntrucciones usan O(1)
   ciclos)
   :END:
   :PROOF: 
   Intel Pentiums and higher, also all modern AMD processors (x86)
   support the "rdtsc" instruction (you can call this from inline
   assembly) which returns a 64-bit count of the number of CPU
   clock cycles since powerup. The clock referred to is the CPU
   code execution cycle, e.g. *a CPU running at 1 GHz runs through
   one billion cycles per second*. (...)
   If your clock is running at 4 GHz then rdtsc measures intervals
   down to 0.25 ns. http://www.velocityreviews.com/forums/t281979-re-how-many-cpu-cycles-does-an-instruction-take.html
   :END:
   Un CPU funciona a 4 GHz: cuanto se demora una instruccion?
   (elija el valor mas cercano).
   1. [ ] 1 nano segundo
   2. [ ] 1 micro segundo
   3. [ ] 1 mili segundo
   4. [ ] 1 centi segundo
   5. [ ] otra respuesta
** Costo (en plata) de la memoria
* Memoria Externa
** Cola de Prioridad: operaciones
   :SOLUTION:     
   Todas se pueden implementar facilamente en un dicionario, pero
   findMind() y extractMin() no son tradicionalemente consideradas
   para un diccionario, mas para una cola de prioridad.
   :END:
   :PROOF: 
   :END:
   Cuáles (no) son operaciones de un diccionario?
   1. [ ] insert(key,item)
   2. [ ] search(key)
   3. [ ] delete(key)
   4. [ ] findNext(key)
   5. [ ] findPrevious(key)
   6. [ ] findMind()
   7. [ ] extractMin()
** $(2,3)$ arboles
   :LOGBOOK:
   :END:
   :SOLUTION:     
   \{la altura, el tiempo de busqueda, el tiempo de insercion, el
   tiempo de delecion\} son en un orden entre $\log_3 n$ y $\log_2
   n$ (ignorando los problemas de constantes).
   :END:
   :PROOF: 
   un arbol binario tiene una altura de $\log_2 n$ y un arbol
   ternario tiene una altura de $\log_3 n$. Un arbol $(2,3)$ tiene
   una altura entre los dos.
   :END:
   Cuál es el orden de \{la altura, el tiempo de búsqueda, el
   tiempo de inserción, el tiempo de eliminación\} de un $(2,3)$-árbol
   con $n$ valores?
   1. [ ] menos que $\log_3 n +O(1)$
   2. [ ] $\log_3 n +O(1)$
   3. [ ] entre  $\log_3 n$ y  $\log_2 n$
   4. [ ] $\log_2 n +O(1)$
   5. [ ] otra respuesta
** $(2,3)$ arboles con $n\in\{8,9,256\}$ elementos		       :CANC:
   :LOGBOOK:
   :END:
   :SOLUTION:     
   \{la altura, el tiempo de busqueda, el tiempo de insercion, el
   tiempo de delecion\} son en 
   :END:
   :PROOF: 
   :END:
   Cuál es \{la altura, el tiempo de búsqueda, el tiempo de
   inserción, el tiempo de eliminación\} de un $(2,3)$-árbol con
   $n\in\{8,9,256\}$ valores?
   1. [ ] menos que $\log_3 n +O(1)$
   2. [ ] $\log_3 n +O(1)$
   3. [ ] entre  $\log_3 n$ y  $\log_2 n$
   4. [ ] $\log_2 n +O(1)$
   5. [ ] otra respuesta
** $B$ arboles vs $(2,3)$ arboles
   :LOGBOOK:
   :END:
   :SOLUTION:     
   Menos que $\log_3 n +O(1)$, por $B>3$, que es verdad en todas
   aplicaciones.
   :END:
   Cuál es \{la altura, el tiempo de búsqueda, el tiempo de
   inserción, el tiempo de eliminación\} de un $B$-árbol con
   $n=\{8,9,256\}$ valores?
   1. [ ] menos que $\log_3 n +O(1)$
   2. [ ] $\log_3 n +O(1)$
   3. [ ] entre  $\log_3 n$ y  $\log_2 n$
   4. [ ] $\log_2 n +O(1)$
   5. [ ] otra respuesta
** Altura de $B$ arboles
   :LOGBOOK:
   - State "NEXT"       from "DONE"       [2011-03-30 Wed 22:09]
   :END:
   :SOLUTION:     
   Menos que $\log_3 n +O(1)$, por $B>3$, que es verdad en todas
   aplicaciones.
   :END:
   Cuál es \{la altura, el tiempo de búsqueda, el tiempo de
   inserción, el tiempo de eliminación\} de un $B$-Arbol sobre
   $n=\{8,9,256\}$ valores, si cada nodo contiene $B$ valores?
   1. [ ] $n/B$
   2. [ ] $\lg n / \lg B$
   3. [ ] $\log_B n$
   4. [ ] $\log_n B$
   5. [ ] otra respuesta
** Relacion hijos/llaves en la raiz de un $B$ arboles
   :LOGBOOK:
   :END:
   Si un nodo de un $B$ arbol tiene $d$ llaves, cuántos hijos
   tiene?
   1. [ ] $d-1$
   2. [ ] $d$
   3. [ ] $d+1$
   4. [ ] $2d+1$
   5. [ ] otra respuesta
** Cantidad de llaves en un nodo de $B$ arbol (Part 1)
   :LOGBOOK:
   :END:
   :SOLUTION:
   $d \in [1,B]$ si ignoramos el arbol vacillo (y contando las
   hojas vacillas como hijos pero no como nodos)
   :END:
   :PROOF:
   el nodo puede ser la raiz, que puede tener menos que $B/2$
   elementos.
   :END:
   :CONTEXT:
   Una pagina de la memoria secundaria puede tener $B$ valores
   juntas con $B+1$ punteros.  
   :END:
   Cuántos hijos ($d$) puede tener un $B$ arbol sobre $n>>B$
   elementos?
   1. [ ] $d \in [0,B/2]$
   2. [ ] $d \in [1,B/2]$
   3. [ ] $d \in [0,B]$
   4. [ ] $d \in [1,B]$
   5. [ ] $d \in [B/2,B]$
   6. [ ] otra respuesta
** Cantidad de llaves en un nodo de $B$ arbol (Part 2)
   :LOGBOOK:
   :END:
   :SOLUTION:
   $d \in [1,B]$
   :END:
   :CONTEXT:
   Una pagina de la memoria secundaria puede tener $B$ valores
   juntas con $B+1$ punteros.  
   :END:
   Una página de la memoria secundaria puede tener $B$ valores
   juntos con $B+1$ punteros. La *raíz* de un $B$-Arbol sobre $n>>B$
   elementos tiene $d$ hijos. Cuál es el dominio de valores
   posibles por $d$?
   1. [ ] $d \in [0,B/2]$
   2. [ ] $d \in [1,B/2]$
   3. [ ] $d \in [0,B]$
   4. [ ] $d \in [1,B]$
   5. [ ] $d \in [B/2,B]$
   6. [ ] otra respuesta
** Cantidad de llaves en un nodo de $B$ arbol (Part 3)
   :LOGBOOK:
   :END:
   :SOLUTION:
   $d \in [B/2,B]$
   :END:
   :PROOF:
   si el nodo no esta la raiz, el debe tener entre $B/2$ y $B$
   valores.
   :END:
   :CONTEXT:
   Una pagina de la memoria secundaria puede tener $B$ valores
   juntas con $B+1$ punteros.  
   :END:
   Un nodo (*distinto de la raiz*) en un $B$-Arbol sobre $n>>B$ elementos tiene $d$
   hijos. Cual es el dominio de valores posibles por $d$?
   1. [ ] $d \in [0,B/2]$
   2. [ ] $d \in [1,B/2]$
   3. [ ] $d \in [0,B]$
   4. [ ] $d \in [1,B]$
   5. [ ] $d \in [B/2,B]$
   6. [ ] otra respuesta
** $B^*$ arboles						       
   :LOGBOOK:
   :END:
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   Un $B^*$ arbol llena sus nodos hasta $2/3$, en vez de $1/2$ por
   los $B$ arboles.
   :END:
   Cuál es el objetivo de un $B^*$-Arbol (en comparación con un $B$-Arbol)? 
   1. [ ] Reducir el tiempo de búsqueda?
   2. [ ] Reducir la cantidad de accesos al cache en búsqueda?
   3. [ ] Reducir la complejidad espacial?
   4. [ ] Reducir la frecuencia de "Split/Merge"?
   5. [ ] Practical [e.g. Optimizacion para data-set (de injeniero)]
   6. [ ] otra respuesta
** $B^+$ arboles
   :SOLUTION:     
   Suportar otro tipos de consultas/busquedas?
   :END:
   :PROOF: 
   Suportar otro tipos de consultas/busquedas, tal que busqueda de
   valores en un interval: se busca para el valor minimal y
   maximal, y se returna el interval en la caldena.
   :END:
   :CONTEXT:
   En $B^+$ arboles, las hojas tienen punteros adicionales formando
   una caldena de todas las hojas. 
   :END:
   Cuál es el objetivo de un $B^+$-Arbol (en comparación con un $B$-Arbol)? 
   1. [ ] Optimizar la Busqueda Secuencial (adaptativa)?
   2. [ ] Suportar otro tipos de consultas/búsquedas?
   3. [ ] Suportar la exportación de los valores en tiempo razonable?
   4. [ ] Practical (e.g. facilitar el back-up de base de datos)?
   5. [ ] otra respuesta
** vEB arboles vs AVL arboles, $(2,3)$ arboles y AVL Arboles	       :CANC:
   :CONTEXT:
   Fija $k$, $m=2^k$, $M=2^m$.  Un vEB arbol de $n$ elementos sobre
   $[0..M-1]$ tiene una raiz con
   - $\sqrt{M}$ punteros a sus ninos $C[0..\sqrt{M}-1]$,
   - dos valores $min$ y $max$
   - un otro vEB $aux$ sobre $[0..\sqrt{M}-1]$
   :END: 
   Que *no* distingue los vEB arboles de las otras estructuras de
   arboles que conocen (e.g. B-arboles) para el ADT diccionario?
   1. [ ] usa el dominio de los valores *para buscar*
   2. [ ] el nodo contiene los elementos extremos (no medios como en un AVL)
   3. [ ] supporta /FindNext/ y /FindPrev/
   4. [ ] sirven para colas de prioridades también
   5. [ ] petmiten de optimizar mejor la memoria
   6. [ ] otra respuesta
** Altura de un vEB arbol
   :SOLUTION:     
   $\lg m$, que es al maximo $\lg\lg n$.
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   Fija $k$, $m=2^k$, $M=2^m$.  Un vEB arbol de $n$ elementos sobre
   $[0..M-1]$ tiene una raiz con
   - $\sqrt{M}$ punteros a sus ninos $C[0..\sqrt{M}-1]$,
   - dos valores $min$ y $max$
   - un otro vEB $aux$ sobre $[0..\sqrt{M}-1]$
   :END: 
   En cual clase asintótica está \{ el tiempo de búsqueda, de
   inserción, de eliminación y la altura \} de un vEB con $n$ valores
   codificadas en $m$ bits?
   1. [ ] $O(\lg n)$
   2. [ ] $O(\lg m)$
   3. [ ] $O(\lg\lg n)$
   4. [ ] $O(\lg\lg m)$
   5. [ ] otra respuesta
** vEB children
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 21:55]
   :END:
   :SOLUTION:     
   $x \over 2^{m/2}$
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   Fija $k$, $m=2^k$, $M=2^m$.  Un vEB arbol de $n$ elementos sobre
   $[0..M-1]$ tiene una raiz con
   - $\sqrt{M}$ punteros a sus ninos $C[0..\sqrt{M}-1]$,
   - dos valores $min$ y $max$
   - un otro vEB $aux$ sobre $[0..\sqrt{M}-1]$
   :END: 
   El valor $x\in]min,max[$ se encuentra en el hijo $C[i]$ donde $i=$
   1. [ ] $2^{m/2} (max - x) \over (max - min)$ 
   2. [ ] $2^{m-2} (max - x) \over (max - min)$ 
   3. [ ] $x \over 2^{m/2}$
   4. [ ] $x \over 2^{m-2}$
   5. [ ] otra respuesta
** vEB aux
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 21:55]
   :END:
   :SOLUTION:     
   Find Next
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   Fija $k$, $m=2^k$, $M=2^m$.  Un vEB arbol de $n$ elementos sobre
   $[0..M-1]$ tiene una raiz con
   - $\sqrt{M}$ punteros a sus ninos $C[0..\sqrt{M}-1]$,
   - dos valores $min$ y $max$
   - un otro vEB $aux$ sobre $[0..\sqrt{M}-1]$
   :END: 
   El rol de $aux$ (o $summary$, como fue visto en la auxiliar) es de 
   memorizar cuales hijos están vacíos.  $j\in aux$ si y sólo si
   $T.C[j]$ es no vacío.  Cuál es el principal objetivo de esto?
   1. [ ] Optimizar Find
   2. [ ] Optimizar Insert
   3. [ ] Optimizar LookUp
   4. [ ] Optimizar FindNext
   5. [ ] otra respuesta
** vEB Find Previous
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 21:55]
   :END:
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   Fija $k$, $m=2^k$, $M=2^m$.  Un vEB arbol de $n$ elementos sobre
   $[0..M-1]$ tiene una raiz con
   - $\sqrt{M}$ punteros a sus ninos $C[0..\sqrt{M}-1]$,
   - dos valores $min$ y $max$
   - un otro vEB $aux$ sobre $[0..\sqrt{M}-1]$
   :END: 
   La complejidade de Find Previous está en 
   1. [ ] $O(k)$
   2. [ ] $O(2^k=m)$
   3. [ ] $O(2^{2^{k-1}})=\sqrt{M}$
   4. [ ] $O(2^{2^k})=M$
   5. [ ] $O((\lg\lg M)^2))$
   6. [ ] otra respuesta
** vEB Insercion
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 21:55]
   :END:
   :SOLUTION:     
   Genera un error
   :END:
   :PROOF: 
   Genera un error: entrada doblada, $x$ tiene que ser a dentro del
   arbol si el es lleno.
   :END:
   :CONTEXT:
   Fija $k$, $m=2^k$, $M=2^m$.  Un vEB arbol de $n$ elementos sobre
   $[0..M-1]$ tiene una raiz con
   - $\sqrt{M}$ punteros a sus ninos $C[0..\sqrt{M}-1]$,
   - dos valores $min$ y $max$
   - un otro vEB $aux$ sobre $[0..\sqrt{M}-1]$
   :END: 
   Si un hijo $C[i]$ está lleno antes de agregar un elemento $x$ adentro.
   1. [ ] Split $C[i]$ en dos
   2. [ ] Mudar algunos elementos de $C[i]$ a sus vecinos, y si no
	  se puede a su padre, recursivamente
   3. [ ] Crea un nuevo sobre árbol con una hoja.
   4. [ ] Genera un error
   5. [ ] otra respuesta
** Cola de Prioridad: operaciones
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 22:49]
   :END:
   :SOLUTION:     
   1. [ ] insert(key,item)
   2. [X] search(key)
   3. [X] delete(key)
   4. [X] findNext(key)
   5. [X] findPrevious(key)
   6. [ ] findMind()
   7. [ ] extractMin()      
   :END:
   :PROOF: 
   search(key) delete(key) findNext(key) findPrevious(key) no son
   en el ADT de colas de prioridades.
   :END:
   Cuales (no) son operaciones de una (min) cola de prioridad?
   1. [ ] insert(key,item)
   2. [ ] search(key)
   3. [ ] delete(key)
   4. [ ] findNext(key)
   5. [ ] findPrevious(key)
   6. [ ] findMin()
   7. [ ] extractMin()
** Colas de Prioridades contra Diccionarios
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 22:49]
   :END:
   :SOLUTION:     
   No son verdades las proposiciones siguientes:
   - $C$ toma menos espacio que $D$
   - $D$ es asintóticamente mas rápido que $C$
   :END:
   :PROOF: 
   Porque no se sabe nada de las complejidad de $C$ y $D$.
   :END:
   Dado estructuras de datos $C$ y $D$, respectivamente
   implementando los ADT "cola de prioridad" y "diccionario". 
   Cual(es) de estas proposiciones tiene(n) problemas?
   1. [ ] $C$ implementa el ADT "diccionario" también.
   2. [ ] $D$ implementa el ADT "cola de prioridad" también.
   3. [ ] $C$ toma menos espacio que $D$
   4. [ ] $D$ es asintóticamente mas rápido que $C$ (en los
      operadores que tienen en común)
   5. [ ] ninguna
** Colas de Prioridades contra Diccionarios
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 22:49]
   :END:
   :SOLUTION:     
   1. [ ] $C$ implementa el ADT "diccionario" también, pero en malo *tiempo*.
   2. [X] $D$ implementa el ADT "cola de prioridad" también, pero en malo *tiempo*.
   3. [X] $C$ implementa el ADT "diccionario" también, pero en malo *espacio*.
   4. [ ] $D$ implementa el ADT "cola de prioridad" también, pero en malo *espacio*.
   5. [X] $C$ implementa el ADT "diccionario" también, pero en malo *tiempo y espacio*.
   6. [X] $D$ implementa el ADT "cola de prioridad" también, pero en malo *tiempo y espacio*.
   :END:
   :PROOF: 
   :END:
   Considera las estructuras de datos Heap $C$ y AVL-árbol $D$,
   respectivamente implementando los ADT "cola de prioridad" y
   "diccionario".  Cual(es) de estas proposiciones tiene(n)
   problemas?
   1. [ ] $C$ implementa el ADT "diccionario" también, pero en malo *tiempo*.
   2. [ ] $D$ implementa el ADT "cola de prioridad" también, pero en malo *tiempo*.
   3. [ ] $C$ implementa el ADT "diccionario" también, pero en malo *espacio*.
   4. [ ] $D$ implementa el ADT "cola de prioridad" también, pero en malo *espacio*.
   5. [ ] $C$ implementa el ADT "diccionario" también, pero en malo *tiempo y espacio*.
   6. [ ] $D$ implementa el ADT "cola de prioridad" también, pero en malo *tiempo y espacio*.
   7. [ ] otra respuesta
** Cola de Prioridad: Heapify
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 22:49]
   :END:
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:
   El operador "Heapify" 
   1. [ ] es parte del ADT "colas de Prioridad"
   2. [ ] es parte de la estructura de datos "Heap"
   3. [ ] tiene complejidad $O(\lg n)$
   3. [ ] tiene complejidad $O(n)$
   3. [ ] tiene complejidad $O(n\lg n)$
   5. [ ] otra respuesta
** Estructuras de datos "Cola de Prioridad"
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 22:50]
   :END:
    Cuales estructuras de datos "Cola de Prioridad" conocen?
      1. [ ] *binary heap*
      2. [ ] sequence-heaps
      3. [ ] /binomial queues/
      4. [ ] /Fibonacci heaps/
      5. [ ] leftist heaps
      6. [ ] min-max heaps
      7. [ ] pairing heaps
      8. [ ] skew heaps
      9. [ ] /van Emde Boas queues/
** Heaps en Memoria Segundaría: Find Min
   :CONTEXT:
   Considera un modelo de memoria segundaría con paginas de tamaño
   para contener $B$ elementos, y un "heap" de $n$ elementos
   ($n>>B$).  
   :END:
   A cuantos accesos a la memoria secundaría corresponde un
   llamado a "FindMin" en un "min heap"?
   1. [X] $1$ acceso
   2. [ ] $\log_B n$ accesos
   3. [ ] $\log n / \log B$ accesos
   4. [ ] $n/B$ accesos
   5. [ ] $n$ accesos
** Heaps en Memoria Segundaría: Delete Min
   :CONTEXT:
   Considera un modelo de memoria segundaría con paginas de tamaño
   para contener $B$ elementos, y un "binary min heap" de $n$
   elementos ($n>>B$).
   :END:
   :SOLUTION:
   $\lg n-\lg B$
   :END:
   A cuantos accesos a la memoria segundaría corresponde un
   llamado a "DeleteMin" en un "min heap"?
   1. [ ] $\log_B n$ accesos
   2. [ ] $(n-B)/B+1$ accesos
   3. [ ] $n/B$ accesos
   4. [ ] $n-B$ accesos
   5. [ ] $n$ accesos
   6. [ ] otra respuesta
** vEB queues: Delete Min
   :CONTEXT:
   Considera un modelo de memoria segundaría con paginas de tamaño
   para contener $B$ elementos, y un "heap" de $n$ elementos
   ($n>>B$).  
   :END:
   :SOLUTION:     
   $\log_B n$ accesos, que $B$ sea conocido o no.
   :END:
   A cuantos accesos a la memoria segundaría corresponde un
   llamado a "DeleteMin" en un vEB Queue?
   1. [ ] $\log_B n$ accesos
   2. [ ] $(n-B)/B+1$ accesos
   3. [ ] $n/B$ accesos
   4. [ ] $n-B$ accesos
   5. [ ] otra respuesta

** vEB queues: cantidad de hijos
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 23:10]
   :END:
   :CONTEXT:
   Considera un modelo de memoria segundaría con paginas de tamaño
   para contener $B$ elementos, y un "vEB queue" de $n$ elementos
   ($n>>B$).
   :END:
   :SOLUTION:     
   
   :END:
   :PROOF: 
   :END:

   Cuanto hijos tiene la raíz de un vEB?
   1. [ ] $2$
   2. [ ] $B$
   3. [ ] $B+1$
   4. [ ] $\sqrt{B}$
   4. [ ] $\sqrt{n}$
   5. [ ] otra respuesta

** vEB queues: altura
   :CONTEXT:
   Considera un modelo de memoria segundaría con paginas de tamaño
   para contener $B$ elementos, y un "vEB queue" de $n$ elementos
   ($n>>B$).  
   :END:
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 23:04]
   :END:
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:
   Cual es la altura de un vEB queue?
   1. [ ] $\log_B\log_B n$
   1. [ ] $\log_2\log_2 n$
   1. [ ] $\log_B n$
   1. [ ] $\log_2 n$
   5. [ ] otra respuesta

** vEB queues: tiempo de búsqueda
   :CONTEXT:
   Considera un modelo de memoria segundaría con paginas de tamaño
   para contener $B$ elementos, y un "vEB queue" de $n$ elementos
   ($n>>B$).  
   :END:
   :LOGBOOK:
   - State "NEXT"       from ""           [2011-03-30 Wed 23:04]
   :END:
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:

   Cual es el tiempo de búsqueda ("findKey(k)") un vEB queue?
   1. [ ] $\log_B\log_B n$
   1. [ ] $\log_2\log_2 n$
   1. [ ] $\log_B n$
   1. [ ] $\log_2 n$
   5. [ ] otra respuesta

** vEB queues: tiempo de "deleteMin"
   :CONTEXT:
   Considera un modelo de memoria segundaría con paginas de tamaño
   para contener $B$ elementos, y un "vEB queue" de $n$ elementos
   ($n>>B$).  
   :END:
   :LOGBOOK:
   - State "TODO"       from "NEXT"       [2011-03-30 Wed 23:07]
   - State "NEXT"       from ""           [2011-03-30 Wed 23:04]
   :END:
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:

   Cual es el tiempo de "deleteMin" en un vEB queue?
   1. [ ] $\log_B\log_B n$
   1. [ ] $\log_2\log_2 n$
   1. [ ] $\log_B n$
   1. [ ] $\log_2 n$
   5. [ ] otra respuesta

** vEB queues: espacio
   :CONTEXT:
   Considera un modelo de memoria segundaría con paginas de tamaño
   para contener $B$ elementos, y un "vEB queue" de $n$ elementos
   ($n>>B$).  
   :END:
   :LOGBOOK:
   - State "TODO"       from ""           [2011-03-30 Wed 23:11]
   :END:
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:

   Cuanto bytes toma un "vEB queue"?
   
   1. [ ] $n$ 
   2. [ ] $k=\lg m$
   3. [ ] $m$
   4. [ ] $M=2^m$
   5. [ ] otra respuesta

** Cotas Inferiores en Memoria Secundaria
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   :END:
   
   Cual(es) de estas afirmaciones esta(n) correctas (en el modelo
   de comparacion)?

   1. [ ] $\Omega(\log_B N)$ por colas de prioridades implicaria $\Omega(\log_B N)$ por diccionarios
   2. [ ] $\Omega(\log_B N)$ por diccionarios implicaria $\Omega(\log_B N)$ por colas de prioridades
   3. [ ] $\Omega(\log_B N)$ por colas de prioridades implicaria $\Omega(N\log_B N)$ por ordenamiento 
   4. [ ] $\Omega(N\log_B N)$ por ordenamiento implicaria $\Omega(\log_B N)$ por colas de prioridades
   5. [ ] ninguna
** Effecto de $M$ sobre /Find/

   La complejidad de /Find/ en un $B$-arbol o vEB arbol es de
   $\lg_B N$ acesos a la memoria segundaria, con $M=1$ paginas en
   memoria principal. Con $M$ mas largo, este complejidad 

   1. [ ] se queda igual
   2. [ ] baja a $\lg_B N / M$
   3. [ ] baja a $\lg_{B/M} N $
   4. [ ] baja a $\lg_B (N/M)$
   5. [ ] Otra respuesta

** Effecto de $M$ sobre /FindMin/

   La complejidad de /Find/ en un $B$-arbol o vEB arbol es de
   $\lg_B N$ acesos a la memoria segundaria, con $M=1$ paginas en
   memoria principal. Con $M$ mas largo, este complejidad 

   1. [ ] se queda igual
   2. [ ] baja a $\lg_B N / M$
   3. [ ] baja a $\lg_{B/M} N $
   4. [ ] baja a $\lg_B (N/M)$
   5. [ ] Otra respuesta

** Complejidad de Insertion Sort en Memoria Segundaria
   :SOLUTION:     
   - =Insertion Sort= (en un B-Arbol) performa $N \lg N / \lg B = N \log_B N$  accesos 
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   Considera que 
   - $B$ = Tamano pagina
   - $N$ = cantidad de elementos en total
   - $n$ = cantidad de paginas con elementos = $N/B$
   - $M$ = cantidad de memoria local
   - $m$ = cantidad de paginas locales = $M/B$
   :END:

   El algoritmo de =Insertion Sort=, con un $B$-arbol, permite de
   ordenar $N$ elementos en

   1. [ ] al menos $N \lg N / \lg B = N \log_B N$  accesos 
   2. [ ] exactamente $N \lg N / \lg B = N \log_B N$  accesos 
   3. [ ] al maximo $N \lg N / \lg B = N \log_B N$  accesos 
   4. [ ] menos que $N \lg N / \lg B = N \log_B N$  accesos 
   5. [ ] otra respuesta

** Complejidad de Heap Sort en Memoria Segundaria
   :SOLUTION:     
   - =Heap Sort= (con una vEB cola) performa $N \lg N / \lg B = N \log_B N$ accesos
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   Considera que 
   - $B$ = Tamano pagina
   - $N$ = cantidad de elementos en total
   - $n$ = cantidad de paginas con elementos = $N/B$
   - $M$ = cantidad de memoria local
   - $m$ = cantidad de paginas locales = $M/B$
   :END:

   El algoritmo de =Heap Sort=, con un vEB-cola de prioridad,
   permite de ordenar $N$ elementos en

   1. [ ] al menos $N \lg N / \lg B = N \log_B N$  accesos 
   2. [ ] exactamente $N \lg N / \lg B = N \log_B N$  accesos 
   3. [ ] al maximo $N \lg N / \lg B = N \log_B N$  accesos 
   4. [ ] menos que $N \lg N / \lg B = N \log_B N$  accesos 
   5. [ ] otra respuesta

** Cota inferior de ordenamiento en memoria segundaria
   :SOLUTION:     
   $\Omega( N/B \frac{ \lg(N/B) }{ \lg(M/B) }  )$
   se nota igualemente $\Omega( n\lg_m n )$      
   :END:
   :PROOF: 
   La cota inferior de $\Omega(n\lg_m n)$ se prueba en las apuntes,
   y en pegacitos en las otras preguntas de conceptos. 

   Las cotas inferiores de $\Omega(N \lg N / \lg B)$ y $\Omega(N
   \log_B N)$ son equivalentes, y faltas, porque el algoritmo de
   mergesort con funnels permite de ordenar $N$ elementos en 
   $O(n\lg_m n)$ acesos, que contradice la cota inferior.
   :END:
   :CONTEXT:
   Considera que 
   - $B$ = Tamano pagina
   - $N$ = cantidad de elementos en total
   - $n$ = cantidad de paginas con elementos = $N/B$
   - $M$ = cantidad de memoria local
   - $m$ = cantidad de paginas locales = $M/B$
   :END:

   Cual de estas cotas inferiores para el problema de ordenar en
   memoria segundaria parece la mas razonable?

   1. [ ] $\Omega( N/B \frac{ \lg(N/B) }{ \lg(M/B) }  )$
   2. [ ] $\Omega( n\lg_m n )$      
   3. [ ] $\Omega(N \lg N / \lg B)$
   4. [ ] $\Omega(N \log_B N)$
   5. [ ] otra respuesta

** Ordenar (a dentro de las) paginas
   :SOLUTION:     
   $n = N/B$
   :END:
   :PROOF: 
   No contamos las comparaciones, solamente los acesos a las $n$
   paginas en memoria segundaria.  Ordenar cada pagina se hace sin
   problema en memoria principal (e.g. si $M=2$ con mergesort, si
   $M=1$ con heapsort).
   :END:
   :CONTEXT:
   Considera que 
   - $B$ = Tamano pagina
   - $N$ = cantidad de elementos en total
   - $n$ = cantidad de paginas con elementos = $N/B$
   - $M$ = cantidad de memoria local
   - $m$ = cantidad de paginas locales = $M/B$
   - un arreglo $A$ contiene unas de las $N!$ permutaciones possibles sobre $N$ elementos.
   :END:

   Cual es el costo asintótico (en cantidad de accesos a la memoria
   secundaria) de ordenar cada bloque (pagina) de $B$ elementos?

   1. [ ] $n = N/B$
   2. [ ] $N = n\times B$
   3. [ ] $n \times B\lg B$
   4. [ ] $N \times B\lg B$
   5. [ ] otra respuesta

** La permutacion escrita
   :SOLUTION:     
   $(N-1)!= N!/N$
   :END:

   Alguien elijo una permutacion muy grande sobre $[1..N]$, una de
   las $N!$ posibles.  El entrega la primera cifra. Cuantas
   permutaciones posibles quedan?


   1. [ ] $N!/(N-1)!$
   2. [ ] $N!/(N-1)$
   3. [ ] $N!/N$
   4. [ ] $N!$
   5. [ ] otra respuesta
	  
** Contando permutaciones (Part 1)
   :SOLUTION:     
   $N! / B!$ 
   :END:
   :PROOF: 
   Si hay $X$ permutaciones posibles, cada vez que un bloque es
   ordenado, eso elimina $X/B!$ permutaciones. Iterar $n$ veces
   (hay $n$ bloques) lleva el resultado.
   :END:
   :CONTEXT:
   Considera que 
   - $B$ = Tamano pagina
   - $N$ = cantidad de elementos en total
   - $n$ = cantidad de paginas con elementos = $N/B$
   - $M$ = cantidad de memoria local
   - $m$ = cantidad de paginas locales = $M/B$
   - un arreglo $A$ contiene unas de las $N!$ permutaciones possibles sobre $N$ elementos;
   :END:

   Cuantas posibilidades de permutaciones quedan en $A$ despues de
   ordenar la primera pagina?

   1. [ ] $n! / B!$
   2. [ ] $N! / B!$ 
   3. [ ] $N! / B\lg B$
   4. [ ] $N!$
   5. [ ] $(N-B)!
   6. [ ] $N!-B!$
   7. [ ] otra respuesta

** Contando permutaciones (Part 2)
   :SOLUTION:     
   $N! / (B!)^n$ 
   :END:
   :PROOF: 
   Si hay $X$ permutaciones posibles, cada vez que un bloque es
   ordenado, eso elimina $X/B!$ permutaciones. Iterar $n$ veces
   (hay $n$ bloques) lleva el resultado.
   :END:
   :CONTEXT:
   Considera que 
   - $B$ = Tamano pagina
   - $N$ = cantidad de elementos en total
   - $n$ = cantidad de paginas con elementos = $N/B$
   - $M$ = cantidad de memoria local
   - $m$ = cantidad de paginas locales = $M/B$
   - un arreglo $A$ contiene unas de las $N!$ permutaciones possibles sobre $N$ elementos;
   - alguien ya ordeno cada bloque de $B$ elementos.
   :END:

   Cuantas posibilidades de permutaciones quedan en $A$ despues de
   ordenar a dentro de las paginas?

   1. [ ] $N! / (B!)^n$ 
   2. [ ] $N! / n!$
   3. [ ] $N! / B!$
   4. [ ] $N!$
   5. [ ] otra respuesta

** Insertando $B$ elementos en un arreglo ordenado de $M$ elementos (Part 1)
   :SOLUTION:     
   $B$ nuevas entradas se pueden quedar de 
   ${M \choose B} = \frac{M!}{B!(M-B)!} = M\times(M-1)\times\ldots\times(M-B+1)$
   maneras distintas      
   :END:

   De cuantas maneras se pueden mezclar $B$ valores en un arreglo
   de $M$ valores?

   1. [ ] ${M \choose B}$
   2. [ ] $\frac{M!}{B!(M-B)!}$
   3. [ ] $M\times(M-1)\times\ldots\times(M-B+1)$
   4. [ ] $M\times(M-1)\times\ldots\times(M-B)$
   5. [ ] otra respuesta

** Insertando $B$ elementos en un arreglo ordenado de $M$ elementos (Part 2)
   :SOLUTION:     
   $X / {M \choose B} = X / \frac{M!}{B!(M-B)!} = X / M\times(M-1)\times\ldots\times(M-B+1)$
   :END:

   Si tenemos $X$ permutaciones posibles, que descubrimos las
   posiciones relatives de $B$ nuevas valores en relacion con $M$
   valores en memoria primaria, cuantas permutaciones quedan?
   
   1. [ ] $X / {M \choose B}$
   2. [ ] $X / \frac{M!}{B!(M-B)!}$
   3. [ ] $X / M\times(M-1)\times\ldots\times(M-B+1)$
   4. [ ] $X / M\times(M-1)\times\ldots\times(M-B)$
   5. [ ] otra respuesta

** Insertando $t$ veces $B$ elementos a dentro de $M$ elementos
   :CONTEXT:
   Considera que 
   - $B$ = Tamano pagina
   - $N$ = cantidad de elementos en total
   - $n$ = cantidad de paginas con elementos = $N/B$
   - $M$ = cantidad de memoria local
   - $m$ = cantidad de paginas locales = $M/B$
   - un arreglo $A$ contiene unas de las $N!$ permutaciones possibles sobre $N$ elementos;
   - alguien ya ordeno cada bloque de $B$ elementos,
   - deseamos "descubrir" cual es la permutacion.
   :END:
   :SOLUTION:     
   $N! /  (B!)^n {M \choose B}^t$
   :END:
   :PROOF: 
   No se olvida que iniciamos el proceso con $N! / ( (B!)^n$
   permutaciones al inicio, y cada etapa reduce la cantidad de
   permutacion de un factor de $1/ {M \choose B}$.
   :END:

   Después de $t$ accessos (distintos) a la memoria externa, la
   cuantidad de permutaciones se reduci a

   1. [ ] $N! /  (B!)^t$
   2. [ ] $N! /  (B!)^n {M \choose B}^t$
   3. [ ] $N! /  {M \choose B}^t $
   4. [ ] $N! / (N-B\times t)!$
   5. [ ] otra respuesta

** Cuantos acesos para reducir a una sola permutacion?
   :SOLUTION:     
     |-----------+--------+---------------------------------------------+-----------------------------------------------|
     | $N!$      | $\leq$ | $(B!)^n {M \choose B}^t$                    |                                               |
     |-----------+--------+---------------------------------------------+-----------------------------------------------|
     | $N \lg N$ | $\leq$ | $n B \lg B + t B \lg \frac{M}{B}$           | $\lg$ cresciente$                             |
     |           |        |                                             | $\lg(x!) \approx x\lg x$                      |
     |           |        |                                             | $\lg {M \choose B} \approx B \lg \frac{M}{B}$ |
     |-----------+--------+---------------------------------------------+-----------------------------------------------|
     | $t$       | $\geq$ | $\frac { N\lg N - nB \lg B }{ B \lg(M/B) }$ | reduccion lineal                              |
     |           | $\geq$ | $\frac { N \lg(N/B) }{ B \lg(M/B) }$        | $\lg(x/y) = \lg x - \lg y$                    |
     |           | $\geq$ | $\frac { n \lg n }{ \lg m }$                | $n=N/B$ y $m=M/B$                             |
     |           | $\geq$ | $n \log_m n$                                | definicion de $\lg_b$                         |
     |-----------+--------+---------------------------------------------+-----------------------------------------------|
   :END:
   Que agumento se usa para cada etapa del razonamiento siguente?

     |-----------+--------+---------------------------------------------|
     | $N!$      | $\leq$ | $(B!)^n {M \choose B}^t$                    |
     |-----------+--------+---------------------------------------------|
     | $N \lg N$ | $\leq$ | $n B \lg B + t B \lg \frac{M}{B}$           |
     |-----------+--------+---------------------------------------------|
     | $t$       | $\geq$ | $\frac { N\lg N - nB \lg B }{ B \lg(M/B) }$ |
     |           | $\geq$ | $\frac { N \lg(N/B) }{ B \lg(M/B) }$        |
     |           | $\geq$ | $\frac { n \lg n }{ \lg m }$          |
     |           | $\geq$ | $n \log_m n$                                |
     |-----------+--------+---------------------------------------------|

   1. [ ] $n=N/B$ y $m=M/B$
   2. [ ] $\lg x$ es cresciente
   4. [ ] $\lg(x/y) = \lg x - \lg y$
   5. [ ] $\lg(x!) \approx x\lg x$
   6. [ ] $\lg {M \choose B} \approx B \lg \frac{M}{B}$
   7. [ ] otra tecnica

** Cota inferior ordenamiento en memoria segundaria
   :SOLUTION:     
   No se puede ordenar en menos que $n \log_m n$ acesos a la memoria segundaria.
   :END:

   Que significa que $t \geq n \log_m n$ ?

   1. [ ] No se puede ordenar en menos que $n \log_m n$ comparaciones.
   2. [ ] No se puede ordenar en menos que $n \log_m n$ acesos a la memoria segundaria.
   3. [ ] Se puede ordenar en menos que $n \log_m n$ comparaciones.
   4. [ ] Se puede ordenar en menos que $n \log_m n$ acesos a la memoria segundaria.
   5. [ ] otra respuesta

** Cota superior ordenamiento en memoria segundaria
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   :END:

   Existe un algoritmo que ordena $N$ elementos (repartidos en $n$
   paginas de al maximo $B$ elementos cada una) en $O(n \log_m n)$
   acesos a la memoria segundaria?

   1. [ ] No
   2. [ ] Si, es una varianta de Merge Sort
   3. [ ] Si, es una varianta de Insertion Sort
   4. [ ] Si, es una varianta de Heap Sort
   5. [ ] Otra Respuesta

** Cantidad de memoria Local
   :SOLUTION:     
   $M$ affecta  /MergeSort/ mucho mas que los otros:
   :END:
   :PROOF: 
   - en Mergesort una valor mas grande de $M$ permite de fusionar
     mas arreglos en parallelos (a cada etapa de la computacion);
   - en Diccionarios y Colas de prioridades, permite solamente de
     memorisar mas de los primeros niveles de la estructura de
     datos (con control del algoritmo de cache), o de cachear mas
     caminos de la estructura de datos (sin control del algoritmo
     de cache).
   :END:
   :CONTEXT:
   :END:

   Dado un tamaño de pagina fijo $B$, en cual problema la cantidad
   $M$ de memoria local (y la cantidad $m$ de paginas que se pueden
   guardar en memoria local) affecta mas la complejidad asintótica?

   1. [ ] /Find/ en ADT Diccionario
   2. [ ] /FindNext/ en ADT Diccionario (e.g. $B$-arbol o van Emde Boas)
   3. [ ] /FindMin/ en ADT Cola de prioridad
   4. [ ] /MergeSort/ 
   5. [ ] todas iguales: mas memoria siempre ayuda.

** Peor Caso de "Insert" en Memoria Secundaria
   :SOLUTION:     
    - $\log_B\log_B N$
    - $\log_2\log_2 N$
    - $\log_B N$
      + $B$-arbol para diccionario
      + $2B$-arbol para diccionario
      + $B/2$-arbol para diccionario
      + vEB-arbol recursivo para colas de prioridades
      + vEB-arbol recursivo  para diccionario
    - $\log_2 N$
      + "min binary heap"
      + avl arbol
      + (2,3)-arbol
    - Otra Respuesta
      + vEB-arbol original para colas de prioridades
      + vEB-arbol original para diccionario
   :END:
   :PROOF:
   - For general large values of $B$, es imposible de lograr a
     $\log_B\log_B N$ en el modelo de comparaciones.
   - vEB's complexity cannot be guaranteed to be in $\log_2\log_2
     N$, when the domain of the values is not specified.
   - Differencia de un factor de 2 en el tamano de B no impacta la
     compleidad asintotica.
   :END:
   :CONTEXT:
    Considera un nivel de memoria tal que 
    - $B$ = Tamano pagina
    - $N$ = cantidad de elementos en total
    - $n$ = cantidad de paginas con elementos = $N/B$
    - $M$ = cantidad de memoria local
    - $m$ = cantidad de paginas locales = $M/B$
   :END:

   Para cada de las estructuras de datos siguentes,
    1) "min binary heap"
    2) avl arbol
    3) (2,3)-arbol
    4) $B$-arbol para diccionario
    5) $2B$-arbol para diccionario
    6) $B/2$-arbol para diccionario
    7) vEB-arbol original para colas de prioridades
    8) vEB-arbol recursivo para colas de prioridades
    9) vEB-arbol original para diccionario
    10) vEB-arbol recursivo  para diccionario

   Cual es el rendimiento (asintótico), en terminos de accesos a la
   memoria secundaria en el peor caso, por un llamado a "Insert"?
   (recuerde que la estructura de datos contiene $N$ elementos)

   1. [ ] $\log_B\log_B N$
   2. [ ] $\log_2\log_2 N$
   3. [ ] $\log_B N$
   4. [ ] $\log_2 N$
   5. [ ] otra respuesta

** Mejor Caso de "Insert" en Memoria Secundaria (Part 1)
   :SOLUTION:     
    - $\log_B\log_B N$
    - $\log_2\log_2 N$
    - $\log_B N$
      + "min binary heap"
      + $B$-arbol para diccionario
      + $2B$-arbol para diccionario
      + $B/2$-arbol para diccionario
    - $\log_2 N$
    - (2,3)-arbol 
      + avl arbol
    - Otra Respuesta
      + Constante
	+ vEB-arbol recursivo para colas de prioridades
	+ vEB-arbol recursivo para diccionario
      + sin cota
	+ vEB-arbol original para colas de prioridades
	+ vEB-arbol original para diccionario
   :END:
   :PROOF:
   - $B$-arboles y $(2,3)$ arboles, aunque pueden agregar un
     elemento en un nodo, igual deben ir hasta el 

   :END:
    - $\log_B\log_B N$
    - $\log_2\log_2 N$
    - $\log_B N$
    - $\log_2 N$
    - otra respuesta (constante)
      - "min binary heap"
      - avl arbol
      - (2,3)-arbol
      - $B$-arbol para diccionario
      - $2B$-arbol para diccionario
      - $B/2$-arbol para diccionario
      - vEB-arbol original para colas de prioridades
      - vEB-arbol recursivo para colas de prioridades
      - vEB-arbol original para diccionario
   :END:
   :CONTEXT:
    Considera un nivel de memoria tal que 
    - $B$ = Tamano pagina
    - $N$ = cantidad de elementos en total
    - $n$ = cantidad de paginas con elementos = $N/B$
    - $M$ = cantidad de memoria local
    - $m$ = cantidad de paginas locales = $M/B$
   :END:

   Para cada de las estructuras de datos siguentes,
    1) "min binary heap"
    2) avl arbol
    3) (2,3)-arbol
    4) $B$-arbol para diccionario
    5) $2B$-arbol para diccionario
    6) $B/2$-arbol para diccionario
    7) vEB-arbol original para colas de prioridades
    8) vEB-arbol recursivo para colas de prioridades
    9) vEB-arbol original para diccionario
    10) vEB-arbol recursivo  para diccionario

   Cual es el rendimiento, en terminos de accesos a la memoria
   secundaria en el *mejor* caso, por un llamado a "Insert" ?

   1. [ ] $\log_B\log_B N$
   2. [ ] $\log_2\log_2 N$
   3. [ ] $\log_B N$
   4. [ ] $\log_2 N$
   5. [ ] otra respuesta

** Mejor Caso de "Insert" en Memoria Secundaria (Part 2)
   :SOLUTION:     
    - $\log_B\log_B N$
    - $\log_2\log_2 N$
    - $\log_B N$
      - $B$-arbol para diccionario
      - $2B$-arbol para diccionario
      - $B/2$-arbol para diccionario
      - vEB-arbol recursivo para colas de prioridades
      - vEB-arbol recursivo para diccionarios
    - $\log_2 N$
      - "min binary heap"
      - avl arbol
      - (2,3)-arbol
    - otra respuesta
      - vEB-arbol original para colas de prioridades
      - vEB-arbol original para diccionario
   :END:
   :CONTEXT:
    Considera un nivel de memoria tal que 
    - $B$ = Tamano pagina
    - $N$ = cantidad de elementos en total
    - $n$ = cantidad de paginas con elementos = $N/B$
    - $M$ = cantidad de memoria local
    - $m$ = cantidad de paginas locales = $M/B$
   :END:

   Para cada de las estructuras de datos siguentes,
    1) "min binary heap"
    2) avl arbol
    3) (2,3)-arbol
    4) $B$-arbol para diccionario
    5) $2B$-arbol para diccionario
    6) $B/2$-arbol para diccionario
    7) vEB-arbol original para colas de prioridades
    8) vEB-arbol recursivo para colas de prioridades
    9) vEB-arbol original para diccionario
    10) vEB-arbol recursivo  para diccionario

   Cual es el rendimiento, en terminos de accesos a la memoria
   secundaria en el *mejor* caso, por un llamado a "Insert" *con un
   nuevo elemento*?

   1. [ ] $\log_B\log_B N$
   2. [ ] $\log_2\log_2 N$
   3. [ ] $\log_B N$
   4. [ ] $\log_2 N$
   5. [ ] otra respuesta

** Ordenamiento en Memoria Secundaria: Cota superior (Part 0)
   :SOLUTION:     
   Insertion Sort, Merge Sort, Heap Sort, pero no Bubble Sort
   :END:
   :CONTEXT:
   Considera un nivel de memoria tal que 
   - $B$ = Tamano pagina
   - $N$ = cantidad de elementos en total
   - $n$ = cantidad de paginas con elementos = $N/B$
   - $M$ = cantidad de memoria local
   - $m$ = cantidad de paginas locales = $M/B$
   :END:

   Cual(es) de los algoritmos siguentes, en su variante adaptada a
   la memoria secundaria, permite(n) de ordenar $N$ elementos en
   $O(N\lg N)$ accesos a la memoria secundaria en el peor caso?

   1. [ ] Insertion Sort
   2. [ ] Merge Sort
   3. [ ] Heap Sort
   4. [ ] Bubble Sort
   5. [ ] otra respuesta

** Ordenamiento en Memoria Secundaria: Cota superior (Part 1)
   :SOLUTION:     
   Insertion Sort, Merge Sort, Heap Sort, pero no Bubble Sort
   :END:
   :CONTEXT:
   Considera un nivel de memoria tal que 
   - $B$ = Tamano pagina
   - $N$ = cantidad de elementos en total
   - $n$ = cantidad de paginas con elementos = $N/B$
   - $M$ = cantidad de memoria local
   - $m$ = cantidad de paginas locales = $M/B$
   :END:

   Cual(es) de los algoritmos siguentes, en su varianta adaptada a la
   memoria secundaria, permite(n) de ordenar $N$ elementos en
   $O(N\log_B N)$ accesos a la memoria secundaria en el peor caso?

   1. [ ] Insertion Sort
   2. [ ] Merge Sort
   3. [ ] Heap Sort
   4. [ ] Bubble Sort
   5. [ ] otra respuesta

** Ordenamiento en Memoria Secundaria: Cota superior (Part 2)
   :SOLUTION:     
   Merge Sort (=funnel sort)
   :END:
   :CONTEXT:
   Considera un nivel de memoria tal que 
   - $B$ = Tamano pagina
   - $N$ = cantidad de elementos en total
   - $n$ = cantidad de paginas con elementos = $N/B$
   - $M$ = cantidad de memoria local
   - $m$ = cantidad de paginas locales = $M/B$
   :END:

   Cual(es) de los algoritmos siguentes, en su varianta adaptada a la
   memoria secundaria, permite(n) de ordenar $N$ elementos en
   $O(n\log_m n)$ accesos a la memoria secundaria en el peor caso?

   1. [ ] Insertion Sort
   2. [ ] Merge Sort
   3. [ ] Heap Sort
   4. [ ] Bubble Sort
   5. [ ] otra respuesta

** Torneo Vencedor: Cota inferior en el peor caso
   :SOLUTION:     
   $N/B$
   :END:
   :PROOF: 
   Es un problema de Max.
   :END:
   :CONTEXT:
   El torneo internacional de Karate se tiene en una isla con
   capacidad por $M=20$ participantes. Una sola nave puede traer
   los $N=200$ participantes, que pudede transportar $B=5$
   participantes al mismo tiempo. Se supone que los niveles de los
   participantes corresponden a un orden total, de manera a ce que
   se pueden ordenar completamente.
   - $M=20$
   - $N=200$
   - $B=5$
   :END:
   
   Cuantos viajes de la nave se necessitan en total para
   identificar el ganador del torneo, en el peor caso?
   1. [ ] $\log_B N$
   2. [ ] $N/B$
   3. [ ] $N\log_B N$
   4. [ ] $N/B + N\log_B N$
   5. [ ] otra respuesta

** Torneo Vencedor: Cota superior en mejor caso
   :SOLUTION:     
   $N/B$, igual, hay que leerlas todas para asegurarse de ser
   correcto.
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   El torneo internacional de Karate se tiene en una isla con
   capacidad por $M=20$ participantes. Una sola nave puede traer
   los $N=200$ participantes, que pudede transportar $B=5$
   participantes al mismo tiempo. Se supone que los niveles de los
   participantes corresponden a un orden total, de manera a ce que
   se pueden ordenar completamente.
   - $M=20$
   - $N=200$
   - $B=5$
   :END:
   
   Cuantos viajes de la nave se necessitan en total para
   identificar el gañador del torneo, en el *mejor* caso?
   1. [ ] $\log_B N$
   2. [ ] $N/B$
   3. [ ] $N\log_B N$
   4. [ ] $N/B + N\log_B N$
   5. [ ] otra respuesta

** Torneo Orden: Cota inferior (Part 1)
   :SOLUTION:     
   - otra respuesta: $n\log_m n$ (es un problema de ordenamiento
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   El torneo internacional de Karate se tiene en una isla con
   capacidad por $M=20$ participantes. Una sola nave puede traer
   los $N=200$ participantes, que pudede transportar $B=5$
   participantes al mismo tiempo. Se supone que los niveles de los
   participantes corresponden a un orden total, de manera a ce que
   se pueden ordenar completamente.
   - $M=20$
   - $N=200$
   - $B=5$
   :END:
   
   Cuantos viajes de la nave se necessitan en total para
   identificar el orden total del torneo, en el peor caso?

   1. [ ] $\log_B N$
   2. [ ] $N/B$
   3. [ ] $N\log_B N$
   4. [ ] $N/B + N\log_B N$
   5. [ ] otra respuesta

** Torneo Orden: Cota inferior (Part 2)
   :SOLUTION:     
   $N/B$
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   El torneo internacional de Karate se tiene en una isla con
   capacidad por $M=20$ participantes. Una sola nave puede traer
   los $N=200$ participantes, que pudede transportar $B=5$
   participantes al mismo tiempo. Se supone que los niveles de los
   participantes corresponden a un orden total, de manera a ce que
   se pueden ordenar completamente.
   - $M=20$
   - $N=200$
   - $B=5$
   :END:
   
   Cuantos viajes de la nave se necessitan en total para
   identificar el orden total sobre los $M=20$ mejores participantes
   del torneo, en el peor caso?

   1. [ ] $\log_B N$
   2. [ ] $N/B$
   3. [ ] $N\log_B N$
   4. [ ] $N/B + N\log_B N$
   5. [ ] otra respuesta

** Torneo Orden: Cota inferior (Part 3)
   :SOLUTION:     
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   El torneo internacional de Karate se tiene en una isla con
   capacidad por $M=20$ participantes. Una sola nave puede traer
   los $N=200$ participantes, que pudede transportar $B=5$
   participantes al mismo tiempo. Se supone que los niveles de los
   participantes corresponden a un orden total, de manera a ce que
   se pueden ordenar completamente.
   - $M=20$
   - $N=200$
   - $B=5$
   :END:
   
   Cuantos viajes de la nave se necessitan en total para
   identificar el orden total sobre los $2M=40$ mejores participantes
   del torneo, en el peor caso?

   1. [ ] $\log_B N$
   2. [ ] $N/B$
   3. [ ] $N\log_B N$
   4. [ ] $N/B + N\log_B N$
   5. [ ] otra respuesta



* Analisis Amortizada
** Analisis Amortizada: arreglo dinamico (Part 1)
   :SOLUTION:     
   $O(n)$
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   :END:
    
   Queremos implementar una pila ("stack") en un arreglo. Iniciamos
   con un arreglo de tamaño $s=1$, y cuando se llena, creamos un
   arreglo mas grande, copiamos todo en en nuevo arreglo y sigamos.

   Cual es el costo amortizado de una insercion si el nuevo arreglo
   es de tamaño $n+1$?

   1. [ ] $O(1)$
   2. [ ] $O(\lg n)$
   3. [ ] $O(n)$
   4. [ ] $O(n^2)$
   5. [ ] otra respuesta

** Analisis Amortizada: arreglo dinamico (Part 2)
   :SOLUTION:     
   $3\in O(1)$
   :END:
   :PROOF: 
   Para cada secuencia de $n$ operaciones, el costo total de copias
   es $1+2+4+8+\ldots+2^i$, donde $2^i< n \leq 2^{i+1}$.  

   La suma es $2^{i+1}-1$, en el peor caso (si $n=2^i+1$) igual a
   $2n-1$ copias. 

   Adicionando eso al costo de las $n$ inserciones da un costo
   total de $3n-1$, amortizado a un costo amortizado por operacion
   de $3\in O(1)$.
   :END:
   :CONTEXT:
   Queremos implementar una pila ("stack") en un arreglo. Iniciamos
   con un arreglo de tamaño $s=1$, y cuando se llena, creamos un
   arreglo mas grande, copiamos todo en en nuevo arreglo y sigamos.
   :END:
   
   Cual es el costo amortizado de una insercion si el nuevo arreglo
   es de tamaño $2n$?

   1. [ ] $O(1)$
   2. [ ] $O(\lg n)$
   3. [ ] $O(n)$
   4. [ ] $O(n^2)$
   5. [ ] otra respuesta

** Analisis Amortizada: arreglo dinamico (Part 3)
   :SOLUTION:     
   de $2+1/3\in O(1)$
   :END:
   :PROOF: 
   Para cada secuencia de $n$ operaciones, el costo total de copias
   es $1+4+16+\ldots+4^i$, donde $4^i< n \leq 4^{i+1}$.  

   La suma es $(4^{i+1}-1)/3$, en el pero caso (si $n=4^i+1$,
   i.e. $4n-5=4^{i+1}-1$) igual a $(4n-5)/3$ copias.

   Adicionando eso al costo de las $n$ inserciones da un costo
   total de $(7n-5)/3$, amortizado a un costo amortizado por
   operacion de $7/3 - 5/3n\in O(1)$ asintoticamente.
   :END:
   :CONTEXT:
   Queremos implementar una pila ("stack") en un arreglo. Iniciamos
   con un arreglo de tamaño $s=1$, y cuando se llena, creamos un
   arreglo mas grande, copiamos todo en en nuevo arreglo y sigamos.
   :END:

   Cual es el costo amortizado de una insercion si el nuevo arreglo
   es de tamaño $4n$? 

   1. [ ] menos que $2$
   2. [ ] $2$
   3. [ ] entre $2$ y $3$
   4. [ ] $3$
   5. [ ] mas que $3$

** Analisis Amortizada: arreglo dinamico (Part 4)
   :SOLUTION:     
   $O(1)$
   :END:
   :PROOF: 
   :END:
   :CONTEXT:
   Queremos implementar una pila ("stack") en un arreglo. Iniciamos
   con un arreglo de tamaño $s=1$, y cuando se llena, creamos un
   arreglo mas grande, copiamos todo en en nuevo arreglo y sigamos.
   :END:
   
   Cual es el costo amortizado de una insercion si el nuevo arreglo
   es de tamaño $n^2$ (y el primero arreglo de tamaño 2)?

   1. [ ] $O(1)$
   2. [ ] $O(\lg n)$
   3. [ ] $O(n)$
   4. [ ] $O(n^2)$
   5. [ ] otra respuesta


